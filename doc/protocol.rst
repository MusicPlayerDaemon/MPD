########
Protocol
########

General protocol syntax
***********************

Protocol overview
=================

The :program:`MPD` command protocol exchanges
line-based text records between client and server over TCP.
Once the client is connected to the server, they conduct a
conversation until the client closes the connection. The
conversation flow is always initiated by the client.

All data between the client and the server is encoded in
UTF-8.

The client transmits a command sequence, terminated by the
newline character ``\n``.  The server will
respond with one or more lines, the last of which will be a
completion code.

When the client connects to the server, the server will answer
with the following line::

 OK MPD version

where ``version`` is a version identifier such as
0.12.2.  This version identifier is the version of the protocol
spoken, not the real version of the daemon.  (There is no way to
retrieve this real version identifier from the connection.)

Requests
========

.. code-block:: none

 COMMAND [ARG...]

If arguments contain spaces, they should be surrounded by double
quotation marks.

Argument strings are separated from the command and any other
arguments by linear white-space (' ' or '\\t').

Responses
=========

A command returns ``OK`` on completion or
``ACK some error`` on failure.  These
denote the end of command execution.

Some commands return more data before the response ends with ``OK``.
Each line is usually in the form ``NAME: VALUE``.  Example::

  foo: bar
  OK

.. _binary:

Binary Responses
----------------

Some commands can return binary data.  This is initiated by a line
containing ``binary: 1234`` (followed as usual by a newline).  After
that, the specified number of bytes of binary data follows, then a
newline, and finally the ``OK`` line.

If the object to be transmitted is large, the server may choose a
reasonable chunk size and transmit only a portion.  Usually, the
response also contains a ``size`` line which specifies the total
(uncropped) size, and the command usually has a way to specify an
offset into the object; this way, the client can copy the whole file
without blocking the connection for too long.

Example::

  foo: bar
  binary: 42
  <42 bytes>
  OK


Failure responses
-----------------

The nature of the error can be gleaned from the information
that follows the ``ACK``.
``ACK`` lines are of the form:

.. code-block:: none

 ACK [error@command_listNum] {current_command} message_text

These responses are generated by a call to
``commandError``. They contain four separate
terms. Let's look at each of them:

- ``error``: numeric value of one
  of the ``ACK_ERROR`` constants defined
  in `src/protocol/Ack.hxx`.

- ``command_listNum``: offset of the command that caused the error in
  a :ref:`Command List <command_lists>`.  An error will always cause a
  command list to terminate at the command that causes the error.

- ``current_command``: name of the command, in a :ref:`Command List
  <command_lists>`, that was executing when the error occurred.

- ``message_text``:
  some (hopefully) informative text that describes the
  nature of the error.

An example might help.  Consider the following sequence
sent from the client to the server::

 command_list_begin
 volume 86
 play 10240
 status
 command_list_end

The server responds with::

 ACK [50@1] {play} song doesn't exist: "10240"

This tells us that the play command, which was the second in the list
(the first or only command is numbered 0), failed with error 50.  The
number 50 translates to ``ACK_ERROR_NO_EXIST`` -- the song doesn't
exist.  This is reiterated by the message text which also tells us
which song doesn't exist.

.. _command_lists:

Command lists
=============

To facilitate faster adding of files etc. you can pass a list
of commands all at once using a command list.  The command
list begins with `command_list_begin` or
`command_list_ok_begin` and ends with
`command_list_end`.

It does not execute any commands until the list has ended.  The
response is a concatentation of all individual responses.
On success for all commands,
``OK`` is returned.  If a command
fails, no more commands are executed and the appropriate
``ACK`` error is returned. If
`command_list_ok_begin` is used,
``list_OK`` is returned for each
successful command executed in the command list.

Ranges
======

Some commands (e.g. :ref:`delete <command_delete>`) allow specifying a
range in the form ``START:END`` (the ``END`` item is not included in
the range, similar to ranges in the Python programming language).  If
``END`` is omitted, then the maximum possible value is assumed.

.. _filter_syntax:

Filters
=======

All commands which search for songs (e.g. :ref:`find <command_find>`
and :ref:`searchadd <command_searchadd>`) share a common filter
syntax::

 find EXPRESSION

``EXPRESSION`` is a string enclosed in parantheses which can be one
of:

- ``(TAG == 'VALUE')``: match a tag value; if there are multiple
  values of the given type, at least one must match.
  ``(TAG != 'VALUE')``: mismatch a tag value; if there are multiple
  values of the given type, none of them must match.
  The special tag ``any`` checks all
  tag types.
  ``AlbumArtist`` looks for
  ``VALUE`` in ``AlbumArtist``
  and falls back to ``Artist`` tags if
  ``AlbumArtist`` does not exist.
  ``VALUE`` is what to find.
  An empty value string means: match only if the given tag type does
  not exist at all; this implies that negation with an empty value
  checks for the existence of the given tag type.

- ``(TAG contains 'VALUE')`` checks if the given value is a substring
  of the tag value.

- ``(TAG =~ 'VALUE')`` and ``(TAG !~ 'VALUE')`` use a Perl-compatible
  regular expression instead of doing a simple string comparison.
  (This feature is only available if :program:`MPD` was compiled with
  :file:`libpcre`)

- ``(file == 'VALUE')``: match the full song URI
  (relative to the music directory).

- ``(base 'VALUE')``: restrict the search to
  songs in the given directory (relative to the music
  directory).

- ``(modified-since 'VALUE')``: compares the
  file's time stamp with the given value (ISO 8601 or UNIX
  time stamp).

- ``(AudioFormat == 'SAMPLERATE:BITS:CHANNELS')``: compares the audio
  format with the given value.  See :ref:`audio_output_format` for a
  detailed explanation.

- ``(AudioFormat =~ 'SAMPLERATE:BITS:CHANNELS')``:
  matches the audio format with the given mask (i.e. one
  or more attributes may be ``*``).

- ``(!EXPRESSION)``: negate an expression.  Note that each expression
  must be enclosed in parantheses, e.g. :code:`(!(artist == 'VALUE'))`
  (which is equivalent to :code:`(artist != 'VALUE')`)

- ``(EXPRESSION1 AND EXPRESSION2 ...)``: combine two or
  more expressions with logical "and".  Note that each expression must
  be enclosed in parantheses, e.g. :code:`((artist == 'FOO') AND
  (album == 'BAR'))`

The :command:`find` commands are case sensitive, while
:command:`search` and related commands ignore case.

Prior to MPD 0.21, the syntax looked like this::

 find TYPE VALUE

Escaping String Values
----------------------

String values are quoted with single or double quotes, and special
characters within those values must be escaped with the backslash
(``\``).  Keep in mind that the backslash is also the escape character
on the protocol level, which means you may need to use double
backslash.

Example expression which matches an artist named ``foo'bar"``::

 (Artist == "foo\'bar\"")

At the protocol level, the command must look like this::

 find "(Artist == \"foo\\'bar\\\"\")"

The double quotes enclosing the artist name must be escaped because
they are inside a double-quoted ``find`` parameter.  The single quote
inside that artist name must be escaped with two backslashes; one to
escape the single quote, and another one because the backslash inside
the string inside the parameter needs to be escaped as well.  The
double quote has three confusing backslashes: two to build one
backslash, and another one to escape the double quote on the protocol
level.  Phew!

To reduce confusion, you should use a library such as `libmpdclient
<https://www.musicpd.org/libs/libmpdclient/>`_ which escapes command
arguments for you.

.. _tags:

Tags
====

The following tags are supported by :program:`MPD`:

* **artist**: the artist name. Its meaning is not well-defined; see "*composer*" and "*performer*" for more specific tags.
* **artistsort**: same as artist, but for sorting. This usually omits prefixes such as "The".
* **album**: the album name.
* **albumsort**: same as album, but for sorting.
* **albumartist**: on multi-artist albums, this is the artist name which shall be used for the whole album. The exact meaning of this tag is not well-defined.
* **albumartistsort**: same as albumartist, but for sorting.
* **title**: the song title.
* **track**: the decimal track number within the album.
* **name**: a name for this song. This is not the song title. The exact meaning of this tag is not well-defined. It is often used by badly configured internet radio stations with broken tags to squeeze both the artist name and the song title in one tag.
* **genre**: the music genre.
* **date**: the song's release date. This is usually a 4-digit year.
* **composer**: the artist who composed the song.
* **performer**: the artist who performed the song.
* **work**: `"a work is a distinct intellectual or artistic creation,
  which can be expressed in the form of one or more audio recordings" <https://musicbrainz.org/doc/Work>`_
* **grouping**: "used if the sound belongs to a larger category of
  sounds/music" (`from the IDv2.4.0 TIT1 description
  <http://id3.org/id3v2.4.0-frames>`_).
* **comment**: a human-readable comment about this song. The exact meaning of this tag is not well-defined.
* **disc**: the decimal disc number in a multi-disc album.
* **label**: the name of the label or publisher.
* **musicbrainz_artistid**: the artist id in the `MusicBrainz <https://picard.musicbrainz.org/docs/mappings/>`_ database.
* **musicbrainz_albumid**: the album id in the `MusicBrainz <https://picard.musicbrainz.org/docs/mappings/>`_ database.
* **musicbrainz_albumartistid**: the album artist id in the `MusicBrainz <https://picard.musicbrainz.org/docs/mappings/>`_ database.
* **musicbrainz_trackid**: the track id in the `MusicBrainz <https://picard.musicbrainz.org/docs/mappings/>`_ database.
* **musicbrainz_releasetrackid**: the release track id in the `MusicBrainz <https://picard.musicbrainz.org/docs/mappings/>`_ database.
* **musicbrainz_workid**: the work id in the `MusicBrainz <https://picard.musicbrainz.org/docs/mappings/>`_ database.

There can be multiple values for some of these tags.  For
example, :program:`MPD` may return multiple
lines with a ``performer`` tag.  A tag value is
a UTF-8 string.

.. _other_metadata:

Other Metadata
==============

The response to :ref:`lsinfo <command_lsinfo>` and similar commands
may contain :ref:`song tags <tags>` and other metadata, specifically:

- ``duration``: the duration of the song in
  seconds; may contain a fractional part.

- ``time``: like ``duration``,
  but as integer value.  This is deprecated and is only here
  for compatibility with older clients.  Do not use.

- ``Range``: if this is a queue item referring only to a portion of
  the song file, then this attribute contains the time range in the
  form ``START-END`` or ``START-`` (open ended); both ``START`` and
  ``END`` are time stamps within the song in seconds (may contain a
  fractional part).  Example: ``60-120`` plays only the second minute;
  "``180`` skips the first three minutes.

- ``Format``: the audio format of the song
  (or an approximation to a format supported by MPD and the
  decoder plugin being used).  When playing this file, the
  ``audio`` value in the :ref:`status <command_status>`
  response should be the same.

- ``Last-Modified``: the time stamp of the
  last modification of the underlying file in ISO 8601
  format.  Example:
  "*2008-09-28T20:04:57Z*"

Recipes
*******

Queuing
=======

Often, users run :program:`MPD` with :ref:`random <command_random>`
enabled, but want to be able to insert songs "before" the rest of the
playlist.  That is commonly called "queuing".

:program:`MPD` implements this by allowing the client to specify a
"priority" for each song in the playlist (commands :ref:`priod
<command_prio>` and :ref:`priodid <command_prioid>`).  A higher
priority means that the song is going to be played before the other
songs.

In "random" mode, :program:`MPD` maintains an
internal randomized sequence of songs.  In this sequence,
songs with a higher priority come first, and all songs with
the same priority are shuffled (by default, all songs are
shuffled, because all have the same priority "0").  When you
increase the priority of a song, it is moved to the front of
the sequence according to its new priority, but always after
the current one.  A song that has been played already (it's
"before" the current song in that sequence) will only be
scheduled for repeated playback if its priority has become
bigger than the priority of the current song.  Decreasing the
priority of a song will move it farther to the end of the
sequence.  Changing the priority of the current song has no
effect on the sequence.  During playback, a song's priority is
reset to zero.

Command reference
*****************

.. note:: For manipulating playlists and playing, there are two sets of
   commands.  One set uses the song id of a song in the playlist,
   while another set uses the playlist position of the song. The
   commands using song ids should be used instead of the commands
   that manipulate and control playback based on playlist
   position. Using song ids is a safer method when multiple
   clients are interacting with :program:`MPD`.

Querying :program:`MPD`'s status
================================

:command:`clearerror`
    Clears the current error message in status (this is also
    accomplished by any command that starts playback).

:command:`currentsong`
    Displays the song info of the current song (same song that
    is identified in status).

.. _command_idle:

:command:`idle [SUBSYSTEMS...]` [#since_0_14]_
    Waits until there is a noteworthy change in one or more
    of :program:`MPD`'s subsystems.  As soon
    as there is one, it lists all changed systems in a line
    in the format ``changed:
    SUBSYSTEM``, where SUBSYSTEM is one of the
    following:

    - ``database``: the song database has been modified after :ref:`update <command_update>`.
    - ``update``: a database update has started or finished.  If the database was modified during the update, the ``database`` event is also emitted.
    - ``stored_playlist``: a stored playlist has been modified, renamed, created or deleted
    - ``playlist``: the queue (i.e. the current playlist) has been modified
    - ``player``: the player has been started, stopped or seeked
    - ``mixer``: the volume has been changed
    - ``output``: an audio output has been added, removed or modified (e.g. renamed, enabled or disabled)
    - ``options``: options like repeat, random, crossfade, replay gain
    - ``partition``: a partition was added, removed or changed
    - ``sticker``: the sticker database has been modified.
    - ``subscription``: a client has subscribed or unsubscribed to a channel
    - ``message``: a message was received on a channel this client is subscribed to; this event is only emitted when the queue is empty

    Change events accumulate, even while the connection is not in
    "idle" mode; no events gets lost while the client is doing
    something else with the connection.  If an event had already
    occurred since the last call, the new :ref:`idle <command_idle>`
    command will return immediately.

    While a client is waiting for `idle`
    results, the server disables timeouts, allowing a client
    to wait for events as long as mpd runs.  The
    `idle` command can be canceled by
    sending the command `noidle` (no other
    commands are allowed). :program:`MPD`
    will then leave `idle` mode and print
    results immediately; might be empty at this time.
    If the optional ``SUBSYSTEMS`` argument
    is used, :program:`MPD` will only send
    notifications when something changed in one of the
    specified subsytems.

.. _command_status:

:command:`status`
    Reports the current status of the player and the volume
    level.

    - ``volume``: ``0-100`` (deprecated: ``-1`` if the volume cannot
      be determined)
    - ``repeat``: ``0`` or ``1``
    - ``random``: ``0`` or ``1``
    - ``single`` [#since_0_15]_: ``0``, ``1``, or ``oneshot`` [#since_0_21]_
    - ``consume`` [#since_0_15]_: ``0`` or ``1``
    - ``playlist``: 31-bit unsigned integer, the playlist version number
    - ``playlistlength``: integer, the length of the playlist
    - ``state``: ``play``, ``stop``, or ``pause``
    - ``song``: playlist song number of the current song stopped on or playing
    - ``songid``: playlist songid of the current song stopped on or playing
    - ``nextsong`` [#since_0_15]_: playlist song number of the next song to be played
    - ``nextsongid`` [#since_0_15]_: playlist songid of the next song to be played
    - ``time``: total time elapsed (of current playing/paused song) in seconds
      (deprecated, use ``elapsed`` instead)
    - ``elapsed`` [#since_0_16]_: Total time elapsed within the
      current song in seconds, but with higher resolution.
    - ``duration`` [#since_0_20]_: Duration of the current song in seconds.
    - ``bitrate``: instantaneous bitrate in kbps
    - ``xfade``: ``crossfade`` in seconds
    - ``mixrampdb``: ``mixramp`` threshold in dB
    - ``mixrampdelay``: ``mixrampdelay`` in seconds
    - ``audio``: The format emitted by the decoder plugin during
      playback, format: ``samplerate:bits:channels``.  See
      :ref:`audio_output_format` for a detailed explanation.
    - ``updating_db``: ``job id``
    - ``error``: if there is an error, returns message here

    :program:`MPD` may omit lines which have no (known) value.  Older
    :program:`MPD` versions used to have a "magic" value for
    "unknown", e.g. ":samp:`volume: -1`".

:command:`stats`
    Displays statistics.

    - ``artists``: number of artists
    - ``albums``: number of albums
    - ``songs``: number of songs
    - ``uptime``: daemon uptime in seconds
    - ``db_playtime``: sum of all song times in the database in seconds
    - ``db_update``: last db update in UNIX time
    - ``playtime``: time length of music played

Playback options
================

:command:`consume {STATE}` [#since_0_15]_
    Sets consume state to ``STATE``,
    ``STATE`` should be 0 or 1.
    When consume is activated, each song played is removed from playlist.

:command:`crossfade {SECONDS}`
    Sets crossfading between songs.

:command:`mixrampdb {deciBels}`
    Sets the threshold at which songs will be overlapped. Like crossfading but doesn't fade the track volume, just overlaps. The songs need to have MixRamp tags added by an external tool. 0dB is the normalized maximum volume so use negative values, I prefer -17dB. In the absence of mixramp tags crossfading will be used. See http://sourceforge.net/projects/mixramp

:command:`mixrampdelay {SECONDS}`
    Additional time subtracted from the overlap calculated by mixrampdb. A value of "nan" disables MixRamp overlapping and falls back to crossfading.

.. _command_random:

:command:`random {STATE}`
    Sets random state to ``STATE``,
    ``STATE`` should be 0 or 1.

:command:`repeat {STATE}`
    Sets repeat state to ``STATE``,
    ``STATE`` should be 0 or 1.

.. _command_setvol:

:command:`setvol {VOL}`
    Sets volume to ``VOL``, the range of
    volume is 0-100.

:command:`single {STATE}` [#since_0_15]_
    Sets single state to ``STATE``,
    ``STATE`` should be ``0``, ``1`` or ``oneshot`` [#since_0_20]_.
    When single is activated, playback is stopped after current song, or
    song is repeated if the 'repeat' mode is enabled.

:command:`replay_gain_mode {MODE}` [#since_0_16]_
    Sets the replay gain mode.  One of
    ``off``,
    ``track``,
    ``album``,
    ``auto``
    .
    Changing the mode during playback may take several
    seconds, because the new settings does not affect the
    buffered data.
    This command triggers the
    ``options`` idle event.

:command:`replay_gain_status`
    Prints replay gain options.  Currently, only the
    variable ``replay_gain_mode`` is
    returned.

:command:`volume {CHANGE}`
    Changes volume by amount ``CHANGE``.
    Deprecated, use :ref:`setvol <command_setvol>` instead.

Controlling playback
====================

:command:`next`
    Plays next song in the playlist.

:command:`pause {PAUSE}`
    Toggles pause/resumes playing, ``PAUSE`` is 0 or 1.

    The use of pause command without the PAUSE argument is deprecated.

:command:`play [SONGPOS]`
    Begins playing the playlist at song number
    ``SONGPOS``.

:command:`playid [SONGID]`
    Begins playing the playlist at song
    ``SONGID``.

:command:`previous`
    Plays previous song in the playlist.

:command:`seek {SONGPOS} {TIME}`
    Seeks to the position ``TIME`` (in
    seconds; fractions allowed) of entry
    ``SONGPOS`` in the playlist.

:command:`seekid {SONGID} {TIME}`
    Seeks to the position ``TIME`` (in
    seconds; fractions allowed) of song
    ``SONGID``.

:command:`seekcur {TIME}`
    Seeks to the position ``TIME`` (in
    seconds; fractions allowed) within the current song.  If
    prefixed by ``+`` or ``-``, then the time is relative to the
    current playing position.

:command:`stop`
    Stops playing.

The Queue
=========

.. note:: The "queue" used to be called "current playlist" or just
          "playlist", but that was deemed confusing, because
          "playlists" are also files containing a sequence of songs.
          Those "playlist files" or "stored playlists" can be
          :ref:`loaded into the queue <command_load>` and the queue
          can be :ref:`saved into a playlist file <command_save>`, but
          they are not to be confused with the queue.

          Many of the command names in this section reflect the old
          naming convention, but for the sake of compatibility, we
          cannot rename commands.

There are two ways to address songs within the queue: by their
position and by their id.

The position is a 0-based index.  It is unstable by design: if you
move, delete or insert songs, all following indices will change, and a
client can never be sure what song is behind a given index/position.

Song ids on the other hand are stable: an id is assigned to a song
when it is added, and will stay the same, no matter how much it is
moved around.  Adding the same song twice will assign different ids to
them, and a deleted-and-readded song will have a new id.  This way, a
client can always be sure the correct song is being used.

Many commands come in two flavors, one for each address type.
Whenever possible, ids should be used.

:command:`add {URI}`
    Adds the file ``URI`` to the playlist
    (directories add recursively). ``URI``
    can also be a single file.

:command:`addid {URI} [POSITION]`
    Adds a song to the playlist (non-recursive) and returns the
    song id. ``URI`` is always a single file or  URL.  For example::

     addid "foo.mp3"
     Id: 999
     OK

:command:`clear`
    Clears the queue.

.. _command_delete:

:command:`delete [{POS} | {START:END}]`
    Deletes a song from the playlist.

:command:`deleteid {SONGID}`
    Deletes the song ``SONGID`` from the
    playlist

:command:`move [{FROM} | {START:END}] {TO}`
    Moves the song at ``FROM`` or range of songs
    at ``START:END`` [#since_0_15]_ to ``TO``
    in the playlist.

:command:`moveid {FROM} {TO}`
    Moves the song with ``FROM`` (songid) to
    ``TO`` (playlist index) in the
    playlist.  If ``TO`` is negative, it
    is relative to the current song in the playlist (if
    there is one).

:command:`playlist`

    Displays the queue.

    Do not use this, instead use :ref:`playlistinfo
    <command_playlistinfo>`.

:command:`playlistfind {TAG} {NEEDLE}`
    Finds songs in the queue with strict
    matching.

:command:`playlistid {SONGID}`
    Displays a list of songs in the playlist.
    ``SONGID`` is optional and specifies a
    single song to display info for.

.. _command_playlistinfo:

:command:`playlistinfo [[SONGPOS] | [START:END]]`
    Displays a list of all songs in the playlist, or if the optional
    argument is given, displays information only for the song
    ``SONGPOS`` or the range of songs
    ``START:END`` [#since_0_15]_

:command:`playlistsearch {TAG} {NEEDLE}`
    Searches case-insensitively for partial matches in the
    queue.

:command:`plchanges {VERSION} [START:END]`
    Displays changed songs currently in the playlist since
    ``VERSION``.  Start and end positions may
    be given to limit the output to changes in the given
    range.

    To detect songs that were deleted at the end of the
    playlist, use playlistlength returned by status command.

:command:`plchangesposid {VERSION} [START:END]`
    Displays changed songs currently in the playlist since
    ``VERSION``.  This function only
    returns the position and the id of the changed song, not
    the complete metadata. This is more bandwidth efficient.

    To detect songs that were deleted at the end of the
    playlist, use playlistlength returned by status command.

.. _command_prio:

:command:`prio {PRIORITY} {START:END...}`
    Set the priority of the specified songs.  A higher
    priority means that it will be played first when
    "random" mode is enabled.

    A priority is an integer between 0 and 255.  The default
    priority of new songs is 0.

.. _command_prioid:

:command:`prioid {PRIORITY} {ID...}`
    Same as :ref:`priod <command_prio>`,
    but address the songs with their id.

:command:`rangeid {ID} {START:END}` [#since_0_19]_
    Since :program:`MPD`
    0.19 Specifies the portion of the
    song that shall be played.  ``START`` and
    ``END`` are offsets in seconds
    (fractional seconds allowed); both are optional.
    Omitting both (i.e. sending just ":") means "remove the
    range, play everything".  A song that is currently
    playing cannot be manipulated this way.

:command:`shuffle [START:END]`
    Shuffles the queue.
    ``START:END`` is optional and specifies
    a range of songs.

:command:`swap {SONG1} {SONG2}`
    Swaps the positions of ``SONG1`` and
    ``SONG2``.

:command:`swapid {SONG1} {SONG2}`
    Swaps the positions of ``SONG1`` and
    ``SONG2`` (both song ids).

:command:`addtagid {SONGID} {TAG} {VALUE}`
    Adds a tag to the specified song.  Editing song tags is
    only possible for remote songs.  This change is
    volatile: it may be overwritten by tags received from
    the server, and the data is gone when the song gets
    removed from the queue.

:command:`cleartagid {SONGID} [TAG]`
    Removes tags from the specified song.  If
    ``TAG`` is not specified, then all tag
    values will be removed.  Editing song tags is only
    possible for remote songs.

Stored playlists
================

Playlists are stored inside the configured playlist directory.
They are addressed with their file name (without the directory
and without the `.m3u` suffix).

Some of the commands described in this section can be used to
run playlist plugins instead of the hard-coded simple
`m3u` parser.  They can access playlists in
the music directory (relative path including the suffix),
playlists in arbitrary location (absolute path including the suffix;
allowed only for clients that are connected via local socket), or
remote playlists (absolute URI with a supported scheme).

:command:`listplaylist {NAME}`
    Lists the songs in the playlist.  Playlist plugins are
    supported.

:command:`listplaylistinfo {NAME}`
    Lists the songs with metadata in the playlist.  Playlist
    plugins are supported.

:command:`listplaylists`
    Prints a list of the playlist directory.
    After each playlist name the server sends its last
    modification time as attribute "Last-Modified" in ISO
    8601 format.  To avoid problems due to clock differences
    between clients and the server, clients should not
    compare this value with their local clock.

.. _command_load:

:command:`load {NAME} [START:END]`
    Loads the playlist into the current queue.  Playlist
    plugins are supported.  A range may be specified to load
    only a part of the playlist.

:command:`playlistadd {NAME} {URI}`
    Adds ``URI`` to the playlist
    `NAME.m3u`.
    `NAME.m3u` will be created if it does
    not exist.

:command:`playlistclear {NAME}`
    Clears the playlist `NAME.m3u`.

:command:`playlistdelete {NAME} {SONGPOS}`
    Deletes ``SONGPOS`` from the
    playlist `NAME.m3u`.

:command:`playlistmove {NAME} {FROM} {TO}`
    Moves the song at position ``FROM`` in
    the playlist `NAME.m3u` to the
    position ``TO``.

:command:`rename {NAME} {NEW_NAME}`
    Renames the playlist `NAME.m3u` to `NEW_NAME.m3u`.

:command:`rm {NAME}`
    Removes the playlist `NAME.m3u` from
    the playlist directory.

.. _command_save:

:command:`save {NAME}`
    Saves the queue to
    `NAME.m3u` in the playlist directory.

The music database
==================

:command:`albumart {URI} {OFFSET}`
    Locate album art for the given song and return a chunk of an album
    art image file at offset ``OFFSET``.

    This is currently implemented by searching the directory the file
    resides in for a file called :file:`cover.png`, :file:`cover.jpg`,
    :file:`cover.tiff` or :file:`cover.bmp`.

    Returns the file size and actual number
    of bytes read at the requested offset, followed
    by the chunk requested as raw bytes (see :ref:`binary`), then a
    newline and the completion code.

    Example::

     albumart foo/bar.ogg 0
     size: 1024768
     binary: 8192
     <8192 bytes>
     OK

:command:`count {FILTER} [group {GROUPTYPE}]`
    Count the number of songs and their total playtime in
    the database matching ``FILTER`` (see
    :ref:`Filters <filter_syntax>`).  The
    following prints the number of songs whose title matches
    "Echoes"::

     count title Echoes

    The *group* keyword may be used to
    group the results by a tag.  The first following example
    prints per-artist counts while the next prints the
    number of songs whose title matches "Echoes" grouped by
    artist::

     count group artist
     count title Echoes group artist

    A group with an empty value contains counts of matching song which
    don't this group tag.  It exists only if at least one such song is
    found.

:command:`getfingerprint {URI}`

    Calculate the song's audio fingerprint.  Example (abbreviated fingerprint)::

      getfingerprint "foo/bar.ogg"
      chromaprint: AQACcEmSREmWJJmkIT_6CCf64...
      OK

    This command is only available if MPD was built with
    :file:`libchromaprint` (``-Dchromaprint=enabled``).

.. _command_find:

:command:`find {FILTER} [sort {TYPE}] [window {START:END}]`
    Search the database for songs matching
    ``FILTER`` (see :ref:`Filters <filter_syntax>`).

    ``sort`` sorts the result by the
    specified tag.  The sort is descending if the tag is
    prefixed with a minus ('-').
    Without ``sort``, the
    order is undefined.  Only the first tag value will be
    used, if multiple of the same type exist.  To sort by
    "Artist", "Album" or "AlbumArtist", you should specify
    "ArtistSort", "AlbumSort" or "AlbumArtistSort" instead.
    These will automatically fall back to the former if
    "\*Sort" doesn't exist.  "AlbumArtist" falls back to just
    "Artist".  The type "Last-Modified" can sort by file
    modification time.

    ``window`` can be used to query only a
    portion of the real response.  The parameter is two
    zero-based record numbers; a start number and an end
    number.

.. _command_findadd:

:command:`findadd {FILTER} [sort {TYPE}] [window {START:END}]`
    Search the database for songs matching
    ``FILTER`` (see :ref:`Filters <filter_syntax>`) and add them to
    the queue.  Parameters have the same meaning as for
    :ref:`find <command_find>`.

.. _command_list:

:command:`list {TYPE} {FILTER} [group {GROUPTYPE}]`
    Lists unique tags values of the specified type.
    ``TYPE`` can be any tag supported by
    :program:`MPD`.

    Additional arguments may specify a :ref:`filter <filter_syntax>`.
    The *group* keyword may be used
    (repeatedly) to group the results by one or more tags.

    The following example lists all album names,
    grouped by their respective (album) artist::

     list album group albumartist

    ``list file`` was implemented in an early :program:`MPD` version,
    but does not appear to make a lot of sense.  It still works (to
    avoid breaking compatibility), but is deprecated.

.. _command_listall:

:command:`listall [URI]`
    Lists all songs and directories in
    ``URI``.

    Do not use this command.  Do not manage a client-side
    copy of :program:`MPD`'s database.  That
    is fragile and adds huge overhead.  It will break with
    large databases.  Instead, query
    :program:`MPD` whenever you need
    something.

.. _command_listallinfo:

:command:`listallinfo [URI]`
    Same as :ref:`listall <command_listall>`,
    except it also returns metadata info in the same format
    as :ref:`lsinfo <command_lsinfo>`

    Do not use this command.  Do not manage a client-side
    copy of :program:`MPD`'s database.  That
    is fragile and adds huge overhead.  It will break with
    large databases.  Instead, query
    :program:`MPD` whenever you need
    something.

:command:`listfiles {URI}`
    Lists the contents of the directory
    ``URI``, including files are not
    recognized by :program:`MPD`.
    ``URI`` can be a path relative to the
    music directory or an URI understood by one of the
    storage plugins.  The response contains at least one
    line for each directory entry with the prefix "file: "
    or "directory: ", and may be followed by file attributes
    such as "Last-Modified" and "size".

    For example, "smb://SERVER" returns a list of all shares
    on the given SMB/CIFS server; "nfs://servername/path"
    obtains a directory listing from the NFS server.

.. _command_lsinfo:

:command:`lsinfo [URI]`
    Lists the contents of the directory
    ``URI``.  The response contains records
    starting with ``file``,
    ``directory`` or
    ``playlist``, each followed by metadata
    (:ref:`tags <tags>` or :ref:`other metadata <other_metadata>`).

    When listing the root directory, this currently returns
    the list of stored playlists.  This behavior is
    deprecated; use "listplaylists" instead.

    This command may be used to list metadata of remote
    files (e.g. URI beginning with "http://" or "smb://").

    Clients that are connected via local socket may
    use this command to read the tags of an arbitrary local
    file (URI is an absolute path).

:command:`readcomments {URI}`
    Read "comments" (i.e. key-value pairs) from the file
    specified by "URI".  This "URI" can be a path relative
    to the music directory or an absolute path.

    This command may be used to list metadata of remote
    files (e.g. URI beginning with "http://" or "smb://").

    The response consists of lines in the form "KEY: VALUE".
    Comments with suspicious characters (e.g. newlines) are
    ignored silently.

    The meaning of these depends on the codec, and not all
    decoder plugins support it.  For example, on Ogg files,
    this lists the Vorbis comments.

:command:`readpicture {URI} {OFFSET}`
    Locate a picture for the given song and return a chunk of the
    image file at offset ``OFFSET``.  This is usually implemented by
    reading embedded pictures from binary tags (e.g. ID3v2's ``APIC``
    tag).

    Returns the following values:

    - ``size``: the total file size
    - ``type``: the file's MIME type (optional)
    - ``binary``: see :ref:`binary`

    If the song file was recognized, but there is no picture, the
    response is successful, but is otherwise empty.

    Example::

     readpicture foo/bar.ogg 0
     size: 1024768
     type: image/jpeg
     binary: 8192
     <8192 bytes>
     OK

.. _command_search:

:command:`search {FILTER} [sort {TYPE}] [window {START:END}]`
    Search the database for songs matching
    ``FILTER`` (see :ref:`Filters <filter_syntax>`).  Parameters
    have the same meaning as for :ref:`find <command_find>`,
    except that search is not case sensitive.

.. _command_searchadd:

:command:`searchadd {FILTER} [sort {TYPE}] [window {START:END}]`
    Search the database for songs matching
    ``FILTER`` (see :ref:`Filters <filter_syntax>`) and add them to
    the queue.

    Parameters have the same meaning as for :ref:`search <command_search>`.

:command:`searchaddpl {NAME} {FILTER} [sort {TYPE}] [window {START:END}]`
    Search the database for songs matching
    ``FILTER`` (see :ref:`Filters <filter_syntax>`) and add them to
    the playlist named ``NAME``.

    If a playlist by that name doesn't exist it is created.

    Parameters have the same meaning as for :ref:`search <command_search>`.

.. _command_update:

:command:`update [URI]`
    Updates the music database: find new files, remove
    deleted files, update modified files.

    ``URI`` is a particular directory or
    song/file to update.  If you do not specify it,
    everything is updated.

    Prints ``updating_db: JOBID`` where
    ``JOBID`` is a positive number
    identifying the update job.  You can read the current
    job id in the :ref:`status <command_status>`
    response.

:command:`rescan [URI]`
    Same as :ref:`update <command_update>`,
    but also rescans unmodified files.

Mounts and neighbors
====================

A "storage" provides access to files in a directory tree.  The
most basic storage plugin is the "local" storage plugin which
accesses the local file system, and there are plugins to
access NFS and SMB servers.

Multiple storages can be "mounted" together, similar to the
`mount` command on many operating
systems, but without cooperation from the kernel.  No
superuser privileges are necessary, beause this mapping exists
only inside the :program:`MPD` process

.. _command_mount:

:command:`mount {PATH} {URI}`
    Mount the specified remote storage URI at the given
    path.  Example::

     mount foo nfs://192.168.1.4/export/mp3

:command:`unmount {PATH}`
    Unmounts the specified path.  Example::

     unmount foo

:command:`listmounts`
    Queries a list of all mounts.  By default, this contains
    just the configured ``music_directory``.
    Example::

     listmounts
     mount:
     storage: /home/foo/music
     mount: foo
     storage: nfs://192.168.1.4/export/mp3
     OK

:command:`listneighbors`
    Queries a list of "neighbors" (e.g. accessible file
    servers on the local net).  Items on that list may be
    used with the :ref:`mount <command_mount>`
    command.  Example::

     listneighbors
     neighbor: smb://FOO
     name: FOO (Samba 4.1.11-Debian)
     OK

Stickers
========

"Stickers" [#since_0_15]_ are pieces of
information attached to existing
:program:`MPD` objects (e.g. song files,
directories, albums; but currently, they are only implemented for
song).  Clients can create arbitrary name/value
pairs.  :program:`MPD` itself does not assume
any special meaning in them.

The goal is to allow clients to share additional (possibly
dynamic) information about songs, which is neither stored on
the client (not available to other clients), nor stored in the
song files (:program:`MPD` has no write
access).

Client developers should create a standard for common sticker
names, to ensure interoperability.

Objects which may have stickers are addressed by their object
type ("song" for song objects) and their URI (the path within
the database for songs).

:command:`sticker get {TYPE} {URI} {NAME}`
    Reads a sticker value for the specified object.

:command:`sticker set {TYPE} {URI} {NAME} {VALUE}`
    Adds a sticker value to the specified object.  If a
    sticker item with that name already exists, it is
    replaced.

:command:`sticker delete {TYPE} {URI} [NAME]`
    Deletes a sticker value from the specified object.  If
    you do not specify a sticker name, all sticker values
    are deleted.

:command:`sticker list {TYPE} {URI}`
    Lists the stickers for the specified object.

:command:`sticker find {TYPE} {URI} {NAME}`
    Searches the sticker database for stickers with the
    specified name, below the specified directory (URI).
    For each matching song, it prints the URI and that one
    sticker's value.

:command:`sticker find {TYPE} {URI} {NAME} = {VALUE}`
    Searches for stickers with the given value.

    Other supported operators are:
    "``<``", "``>``"

Connection settings
===================

:command:`close`
    Closes the connection to :program:`MPD`.
    :program:`MPD` will try to send the
    remaining output buffer before it actually closes the
    connection, but that cannot be guaranteed.  This command
    will not generate a response.

    Clients should not use this command; instead, they should just
    close the socket.

:command:`kill`
    Kills :program:`MPD`.

    Do not use this command.  Send ``SIGTERM`` to :program:`MPD`
    instead, or better: let your service manager handle :program:`MPD`
    shutdown (e.g. :command:`systemctl stop mpd`).

:command:`password {PASSWORD}`
    This is used for authentication with the server.
    ``PASSWORD`` is simply the plaintext
    password.

:command:`ping`
    Does nothing but return "OK".

:command:`tagtypes`
    Shows a list of available tag types.  It is an
    intersection of the ``metadata_to_use``
    setting and this client's tag mask.

    About the tag mask: each client can decide to disable
    any number of tag types, which will be omitted from
    responses to this client.  That is a good idea, because
    it makes responses smaller.  The following
    ``tagtypes`` sub commands configure this
    list.

:command:`tagtypes disable {NAME...}`
    Remove one or more tags from the list of tag types the
    client is interested in.  These will be omitted from
    responses to this client.

:command:`tagtypes enable {NAME...}`
    Re-enable one or more tags from the list of tag types
    for this client.  These will no longer be hidden from
    responses to this client.

:command:`tagtypes clear`
    Clear the list of tag types this client is interested
    in.  This means that :program:`MPD` will
    not send any tags to this client.

:command:`tagtypes all`
    Announce that this client is interested in all tag
    types.  This is the default setting for new clients.

Partition commands
==================

These commands allow a client to inspect and manage
"partitions".  A partition is one frontend of a multi-player
MPD process: it has separate queue, player and outputs.  A
client is assigned to one partition at a time.

:command:`partition {NAME}`
    Switch the client to a different partition.

:command:`listpartitions`
    Print a list of partitions.  Each partition starts with
    a ``partition`` keyword and the
    partition's name, followed by information about the
    partition.

:command:`newpartition {NAME}`
    Create a new partition.

Audio output devices
====================

:command:`disableoutput {ID}`
    Turns an output off.

:command:`enableoutput {ID}`
    Turns an output on.

:command:`toggleoutput {ID}`
    Turns an output on or off, depending on the current
    state.

.. _command_outputs:

:command:`outputs`
    Shows information about all outputs.
    
    ::

        outputid: 0
        outputname: My ALSA Device
        plugin: alsa
        outputenabled: 0
        attribute: dop=0
        OK

    Return information:

    - ``outputid``: ID of the output. May change between executions
    - ``outputname``: Name of the output. It can be any.
    - ``outputenabled``: Status of the output. 0 if disabled, 1 if enabled.

:command:`outputset {ID} {NAME} {VALUE}`
    Set a runtime attribute.  These are specific to the
    output plugin, and supported values are usually printed
    in the :ref:`outputs <command_outputs>`
    response.

Reflection
==========

:command:`config`
    Dumps configuration values that may be interesting for
    the client.  This command is only permitted to "local"
    clients (connected via local socket).

    The following response attributes are available:

    - ``music_directory``: The absolute path of the music directory.

:command:`commands`
    Shows which commands the current user has access to.

:command:`notcommands`
    Shows which commands the current user does not have
    access to.

:command:`urlhandlers`
    Gets a list of available URL handlers.

:command:`decoders`
    Print a list of decoder plugins, followed by their
    supported suffixes and MIME types.  Example response::

     plugin: mad
     suffix: mp3
     suffix: mp2
     mime_type: audio/mpeg
     plugin: mpcdec
     suffix: mpc

Client to client
================

Clients can communicate with each others over "channels".  A
channel is created by a client subscribing to it.  More than
one client can be subscribed to a channel at a time; all of
them will receive the messages which get sent to it.

Each time a client subscribes or unsubscribes, the global idle
event ``subscription`` is generated.  In
conjunction with the :ref:`channels <command_channels>`
command, this may be used to auto-detect clients providing
additional services.

New messages are indicated by the ``message``
idle event.

:command:`subscribe {NAME}`
    Subscribe to a channel.  The channel is created if it
    does not exist already.  The name may consist of
    alphanumeric ASCII characters plus underscore, dash, dot
    and colon.

:command:`unsubscribe {NAME}`
    Unsubscribe from a channel.

.. _command_channels:

:command:`channels`
    Obtain a list of all channels.  The response is a list
    of "channel:" lines.

:command:`readmessages`
    Reads messages for this client.  The response is a list
    of "channel:" and "message:" lines.

:command:`sendmessage {CHANNEL} {TEXT}`
    Send a message to the specified channel.

.. rubric:: Footnotes

.. [#since_0_14] Since :program:`MPD` 0.14
.. [#since_0_15] Since :program:`MPD` 0.15
.. [#since_0_16] Since :program:`MPD` 0.16
.. [#since_0_19] Since :program:`MPD` 0.20
.. [#since_0_20] Since :program:`MPD` 0.20
.. [#since_0_21] Since :program:`MPD` 0.21
